#!/data/data/com.termux/files/usr/bin/sh
# Convert text file into man page

# Copyright (C) 2001, 2002, 2003 Marc Vertes

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

# release 1.5.6

usage()
{
    echo
    echo " Usage: txt2man [-hp] [-t mytitle] [-P pname] [-r rel]"
    echo "                [-s sec] [-v vol] [-I txt] [-B txt]"
    echo "                [-d date] [infile]"
    echo
    echo " Convert text file into man(7) page."
    echo
    echo " Options:"
    echo "  -h          Print this help."
    echo
    echo "  -d date     Set date in header. Defaults to current"
    echo "              date."
    echo
    echo "  -P pname    Set pname as project name in header."
    echo "              Defaults to uname -s."
    echo
    echo "  -p          Probe title, section name and volume."
    echo
    echo "  -t mytitle  Set mytitle as title of generated man page."
    echo
    echo "  -r rel      Set rel as project name and release."
    echo
    echo "  -s sec      Set sec as section in heading, ususally"
    echo "              a value from 1 to 8."
    echo
    echo "  -v vol      Set vol as volume name,"
    echo "              i.e. \"Unix user 's manual\"."
    echo
    echo "  -I txt      Italicize txt in output. Can be specified"
    echo "              more than once."
    echo
    echo "  -B txt      Emphasize (bold) txt in output. Can be"
    echo "              specified more than once."
    echo
}

sys=$(uname -s)
rel=
volume=
section=
title=untitled
doprobe=
itxt=
btxt=
post=cat

while getopts :d:hpr:s:t:v:P:I:B: opt; do
    case $opt in
        (d) date=$OPTARG;;
        (r) rel=$OPTARG;;
        (t) title=$OPTARG;;
        (s) section=$OPTARG;;
        (v) volume=$OPTARG;;
        (P) sys=$OPTARG;;
        (p) doprobe=1;;
        (I) itxt="$OPTARG§$itxt";;
        (B) btxt=$OPTARG;;
        (h) usage; exit 0;;
        (*) usage; exit 1;;
    esac
done
shift $(($OPTIND - 1))
date=${date:-$(date +'%d %B %Y')}

if test "$doprobe"; then
    title=${1##*/}; title=${title%.txt}

    if grep -q '#include ' $1; then
        section=${section:-3}
        volume=${volume:-"$sys Programmer's Manual"}
    else
        section=${section:-1}
        volume=${volume:-"$sys Reference Manual"}
    fi

    # get release from path
    rel=$(pwd | sed 's:/.*[^0-9]/::g; s:/.*::g')
fi

head="\" Text automatically generated by txt2man
.TH $title $section \"$date\" \"$rel\" \"$volume\""

# All tabs converted to spaces
expand $* |
# gawk is needed because use of non standard regexp
gawk --re-interval -v head="$head" -v itxt="$itxt" -v btxt="$btxt" '
BEGIN {
    print ".\\" head
    avar[1] = btxt; avar[2] = itxt

    for (k in avar) {
        mark = (k == 1) ? "\\fB" : "\\fI"
        split(avar[k], tt, "§")

        for (i in tt)
            if (tt[i] != "")
                subwords["\\<" tt[i] "\\>"] = mark tt[i] "\\fP"

        for (i in tt)
            delete tt[i]
    }

    for (k in avar)
        delete avar[k]
}
{
    # to avoid some side effects in regexp
    gsub(/\.\.\./, "\\.\\.\\.")
    # remove spaces in empty lines
    sub(/^ +$/,"")
}
/^[[:upper:][:space:]]+$/ {
	# Section header
    if ((in_bd + 0) == 1) {
        in_bd = 0
        print ".fam T\n.fi"
    }

    if (section == "SYNOPSIS") {
        print ".fam T\n.fi"
        type["SYNOPSIS"] = ""
    }

    if ($0 ~/^[^[:space:]]/)
        print ".SH " $0
    else
        print ".SS" $0

    sub(/^ +/, "")
    section = $0

    if (section == "SYNOPSIS") {
        print ".nf\n.fam C"
        in_bd = 1
    }

    ls = 0      # line start index
    pls = 0     # previous line start index
    pnzls = 0   # previous non zero line start index
    ni = 0      # indent level
    ind[0] = 0	# indent offset table
    prevblankline = 0
    next
}
{
	# Compute line start index, handle start of example display block
    pls = ls

    if (ls != 0)
        pnzls = ls

    match($0, /[^ ]/)
    ls = RSTART

    if (pls == 0 && pnzls > 0 && ls > pnzls && $1 !~ /^[0-9\-\*\o]\.*$/) {
        # example display block
        if (prevblankline == 1) {
            print ".PP"
            prevblankline = 0
        }

        print ".nf\n.fam C"
        in_bd = 1
        eoff = ls
    }

    if (ls > 0 && ind[0] == 0)
        ind[0] = ls
}
(in_bd + 0) == 1 {
	# In block display
    if (section == "SYNOPSIS")
        ;
    else if (ls != 0 && ls < eoff) {
        # End of litteral display block
        in_bd = 0
        print ".fam T\n.fi"
    } else { print; next }
}
section == "NAME" {
    $1 = "\\fB" $1
    sub(/ \- /, " \\fP- ")
}
section == "SYNOPSIS" {
	# Identify arguments of fcts and cmds
    if (type["SYNOPSIS"] == "") {
        if ($0 ~ /\(/)
            type["SYNOPSIS"] = "fct"
        else if ($1 == "struct" || $2 == "struct")
            type["SYNOPSIS"] = "struct"
        else if ($1 && $1 !~ /^#|typedef|struct|union|enum/)
            type["SYNOPSIS"] = "cmd"
    }

    if (type["SYNOPSIS"] == "cmd") {
        # Line is a command line
        if ($1 !~ /^\[/) {
            b = $1
            sub(/^\*/, "", b)
            subwords["\\<" b "\\>"] = "\\fB" b "\\fP"
        }

        for (i = 2; i <= NF; i++) {
            a = $i
            gsub(/[\[\]\|]/, "", a)

            if (a ~ /^[^\-]/)
                subwords["\\<" a "\\>"] = "\\fI" a "\\fP"
        }
    } else if (type["SYNOPSIS"] == "fct") {
        # Line is a C function definition
        if ($1 == "typedef") {
            if ($0 !~ /\(\*/)
                subwords["\\<" $2 "\\>"] = "\\fI" $2 "\\fP"
        } else if ($1 == "#define")
            subwords["\\<" $2 "\\>"] = "\\fI" $2 "\\fP"

        for (i = 1; i <= NF; i++) {
            if ($i ~ /[\,\)]\;*$/) {
                a = $i
                sub(/.*\(/, "", a)
                gsub(/\W/, "", a)
                subwords["\\<" a "\\>"] = "\\fI" a "\\fP"
            }
        }
    }
}
{
	# protect dots inside words
    while ($0  ~ /\w\.\w/)
        sub(/\./, "_dOt_")

    # identify func calls and cross refs
    for (i = 1; i <= NF; i++) {
        b = $i
        sub(/^\*/, "", b)

        if ((a = index(b, ")(")) > 3) {
            w = substr(b, 3, a - 3)
            subwords["\\<" w "\\>"] = "\\fI" w "\\fP"
        }

        if ((a = index(b, "(")) > 1) {
            w = substr(b, 1, a - 1)
            subwords["\\<" w "\\("] = "\\fB" w "\\fP("
        }
    }

    # word attributes
    n = asorti(subwords, indices)

    for (i = 1; i <= n; i++)
        gsub(indices[i], subwords[indices[i]])

    # shell options
    gsub(/\B\-+\w+(\-\w+)*/, "\\fB&\\fP")

    # unprotect dots inside words
    gsub(/_dOt_/, ".")

    if (section == "SYNOPSIS") {
        sub(/^  /, "")
        print
        next
    }

    if (match($0, /[^ ]  +/) > 0) {
        # tag list item
        adjust_indent()
        tag = substr($0, 1, RSTART)
        sub(/^ */, "", tag)

        if (RSTART+RLENGTH < length())
            $0 = substr($0, RSTART + RLENGTH)
        else
            $0 = ""

        print ".TP\n.B"
        print tag
        prevblankline = 0

        if (NF == 0)
            next
    } else if ($1 == "-"||$1 == "o"||$1 == "*") {
        # bullet list item
        adjust_indent()
        print ".IP \\(bu 3"
        prevblankline = 0
        $1 = ""
    } else if ($1 ~ /^[0-9]+[\).]$/) {
        # enum list item
        adjust_indent()
        print ".IP " $1 " 4"
        prevblankline = 0
        $1 = ""
    } else if (pls == 0) {
        # new paragraph
        adjust_indent()
    } else if (NF == 0) {
        # blank line
        prevblankline = 1
        next
    } else
        prevblankline = 0

    # flush vertical space
    if (prevblankline == 1) {
        print ".PP"
        prevblankline = 0
    }

    if (section != "SYNOPSIS" || $0 ~ /^ {1,4}/)
        sub(/ */,"")

    # Protect lines starting by simple quotes
    sub(/^'\''/, "\\(cq")
    print
}

function adjust_indent()
{
    if (ls > ind[ni]) {
        ind[++ni] = ls
        print ".RS"
    } else if (ls < ind[ni]) {
        while (ls < ind[ni]) {
            ni--
            print ".RE"
        }
    }
}
' | eval $post
